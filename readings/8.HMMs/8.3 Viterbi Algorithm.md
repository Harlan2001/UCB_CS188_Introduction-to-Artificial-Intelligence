### 8.3 Viterbi 算法

在前向算法中，我们使用递归求解了  

\[
P(X_N \mid e_{1:N})
\]  

即给定目前观测到的证据变量，系统可能处于各状态的概率分布。  

另一个与隐藏马尔可夫模型相关的重要问题是：**在给定已观察证据变量的情况下，系统最可能经历的隐藏状态序列是什么？**  
换句话说，我们希望求解：

\[
\arg\max_{x_{1:N}} P(x_{1:N} \mid e_{1:N}) = \arg\max_{x_{1:N}} P(x_{1:N}, e_{1:N})
\]

这个轨迹同样可以通过动态规划使用 **Viterbi 算法**求解。

---

算法包括两个阶段：

1. **前向阶段**：沿时间前进，计算到每个 \((状态, 时间)\) 元组的最优路径概率，条件是已观察到的证据。
2. **回溯阶段**：  
   - 首先找到终态 \(x_N\) ，它位于概率最高的路径上  
   - 然后沿时间反向遍历，沿着通向该终态的路径回溯（该路径必然是最优路径）

---

可视化：状态格（State Trellis）  

![](../../image/8.HMMs/trellis.png)

- 在具有两个可能隐藏状态（如 sun 或 rain）的 HMM 中，我们希望计算从 \(X_1\) 到 \(X_N\) 的概率最高路径（每个时间步的状态分配）。
- 从 \(X_{t-1}\) 到 \(X_t\) 的边权重为：

\[
P(X_t \mid X_{t-1}) P(E_t \mid X_t)
\]

- 一条路径的概率为路径上边权重的乘积
  - 第一个乘子表示特定转移的可能性
  - 第二个乘子表示观察到证据与该状态的契合度

---

回忆：

\[
P(X_{1:N}, e_{1:N}) = P(X_1) P(e_1 \mid X_1) \prod_{t=2}^{N} P(X_t \mid X_{t-1}) P(e_t \mid X_t)
\]

- 前向算法计算（归一化之前的）  

\[
P(X_N, e_{1:N}) = \sum_{x_1, ..., x_{N-1}} P(X_N, x_{1:N-1}, e_{1:N})
\]

- Viterbi 算法我们要求：

\[
\arg\max_{x_1, ..., x_N} P(x_{1:N}, e_{1:N})
\]

以获得隐藏状态序列的最大似然估计。

---

注意：乘积中的每一项正好对应状态格中 \(t-1 \to t\) 的边权重。  
因此，路径上边权重的乘积给出了该路径在给定证据下的概率。

我们可以为所有可能的隐藏状态构建联合概率表，但空间复杂度呈指数级。  
利用动态规划可以在多项式时间内求解最优路径，而不必在任何时刻存储完整表格。

---

定义：

\[
m_t[x_t] = \max_{x_{1:t-1}} P(x_{1:t}, e_{1:t})
\]

- 表示从任意 \(x_0\) 出发，到时间 \(t\) 处于状态 \(x_t\) 的路径概率最大值  
- 同时也是状态格中从步骤 1 到 \(t\) 的最优路径权重

递推公式：

\[
\begin{aligned}
m_t[x_t] &= \max_{x_{1:t-1}} P(e_t \mid x_t) P(x_t \mid x_{t-1}) P(x_{1:t-1}, e_{1:t-1}) \\
&= P(e_t \mid x_t) \max_{x_{t-1}} P(x_t \mid x_{t-1}) \underbrace{\max_{x_{1:t-2}} P(x_{1:t-1}, e_{1:t-1})}_{m_{t-1}[x_{t-1}]} \\
&= P(e_t \mid x_t) \max_{x_{t-1}} P(x_t \mid x_{t-1}) m_{t-1}[x_{t-1}]
\end{aligned}
\]

这表明我们可以通过动态规划递归计算 \(m_t\) 对所有 \(t\)。

---

为了重建完整路径，需要记录每个状态的最佳前驱：

\[
a_t[x_t] = P(e_t \mid x_t) \arg\max_{x_{t-1}} P(x_t \mid x_{t-1}) m_{t-1}[x_{t-1}] = \arg\max_{x_{t-1}} P(x_t \mid x_{t-1}) m_{t-1}[x_{t-1}]
\]

---
```python
算法总结：

结果: 最可能的隐藏状态序列 x1:N

/* 前向递推 */
# 算法总结：
# 结果: 最可能的隐藏状态序列 x_1:N

# 前向递推
for t in range(1, N+1):            # t = 1 ... N
    for x_t in X:                  # 遍历每个状态 x_t
        if t == 1:
            m[t][x_t] = P(x_t) * P(e_1 | x_t)  # 初始时间步
        else:
            a[t][x_t] = argmax_x_{t-1} ( P(x_t | x_{t-1}) * m[t-1][x_{t-1}] )
            m[t][x_t] = P(e_t | x_t) * P(x_t | a[t][x_t]) * m[t-1][a[t][x_t]]

# 找到最可能路径的终态
x_N = argmax_x_N m[N][x_N]

# 反向回溯得到隐藏状态
for t in range(N, 1, -1):
    x_{t-1} = a[t][x_t]

```

注意，我们的 `a` 数组定义了一组长度为 N 的序列，每条序列对应某个特定终态 x_N 的最可能路径。  
当前向递推完成后，我们查看这 N 条序列的概率，选择最优的一条，并在反向回溯中重建该序列。  
由此，我们就在多项式时间和空间复杂度下计算出了证据的最可能解释。



