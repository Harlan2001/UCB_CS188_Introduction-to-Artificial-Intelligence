## 2.4 排序（Ordering）

我们已经说明，在求解 CSP 时，需要为**变量**和**取值**固定某种排序方式。在实际应用中，通常更高效的做法是基于以下两个总体原则，**动态地（on the fly）** 决定下一个要赋值的变量及其对应的取值：**最少剩余值**与**最少约束值**。

- **最少剩余值（Minimum Remaining Values, MRV）** ——  
  在选择下一个要赋值的变量时，MRV 策略会选择**剩余合法取值数量最少**的那个未赋值变量（即**约束最强**的变量）。这一策略在直觉上是合理的：约束最强的变量最有可能率先耗尽可用取值，从而导致回溯，因此最好尽早对其进行赋值。

- **最少约束值（Least Constraining Value, LCV）** ——  
  类似地，在选择要赋给某个变量的取值时，一个良好的策略是选择**对其余未赋值变量的取值域裁剪最少**的那个取值。需要注意的是，这种策略通常需要额外的计算开销（例如，对每一个候选取值重新运行弧一致性、前向检查或其他过滤方法，以确定哪个取值是 LCV），但在具体使用中，仍然可能带来整体求解速度的提升。

## 2.4.1 结构（Structure）

解决约束满足问题的最后一类改进方法，是**利用问题本身的结构**。特别地，如果我们要解决的是一个**树结构 CSP**（即其约束图中不包含环），那么我们可以将求解运行时间从 $O(d^N)$ 降低到 $O(nd^2)$，即关于变量数量是线性的。这可以通过**树结构 CSP 算法**来实现，其基本步骤如下：

1. 首先，在 CSP 的约束图中任选一个节点作为树的根节点（选择哪一个并不重要，因为基础图论告诉我们：树中的任何节点都可以作为根）。
2. 将树中的所有无向边转换为**指向远离根节点方向的有向边**。随后，对所得的有向无环图进行**线性化（或拓扑排序）**。通俗地说，这一步就是对图中的节点进行排序，使得所有边都从左指向右。注意到我们选择节点 $A$ 作为根，并令所有边都指向远离 $A$ 的方向后，这一过程会将下述 CSP 转换为相应形式：
   
    ![](../../image/2.CSPs/tree-structured-alg.png)

   *Tree-structured CSP*

3. 执行一次**反向的弧一致性传播**。从 $i = n$ 迭代到 $i = 2$，对所有弧  
   $$Parent(X_i) \rightarrow X_i$$  
   强制执行弧一致性。对于上面线性化后的 CSP，这一步取值域裁剪会消除若干取值，最终得到如下结果：

    ![](../../image/2.CSPs/pruned-tree.png)

   *Pruned tree*

4. 最后，执行一次**前向赋值**。从 $X_1$ 开始一直到 $X_n$，依次为每个 $X_i$ 选择一个与其父节点取值一致的取值。由于我们已经在所有这些弧上强制执行了弧一致性，因此无论我们为任意节点选择哪个取值，都可以保证它的每一个子节点至少存在一个一致的取值。因此，这种迭代式赋值过程一定能够得到一个正确解，这一点可以通过简单的数学归纳法加以证明。

树结构 CSP 算法还可以通过**割集条件化（cutset conditioning）**推广到那些“接近树结构”的 CSP。割集条件化的思想是：首先在约束图中找到一个**最小的变量子集**，使得移除这些变量后，剩余图结构变成一棵树（这样的子集被称为图的一个**割集（cutset）**）。例如，在我们的地图着色示例中，南澳大利亚州（$SA$）就是一个最小的割集：

![](../../image/2.CSPs/cutset.png)

*Cutset example*

在找到最小割集之后，我们首先为割集中的所有变量赋值，并对其所有相邻节点的取值域进行裁剪。此时，剩余部分就构成了一个树结构 CSP，可以使用上面介绍的树结构 CSP 算法来求解。需要注意的是，对大小为 $c$ 的割集进行初始赋值后，经过取值域裁剪，得到的树结构 CSP 可能并不存在可行解，因此我们仍然可能需要进行最多 $d^c$ 次回溯。由于移除割集后，剩余的是一个包含 $(n-c)$ 个变量的树结构 CSP，而它可以在 $O((n-c)d^2)$ 时间内被求解（或判定无解），因此，割集条件化在一般 CSP 上的总体运行时间为：

$$
O\big(d^c (n-c) d^2\big),
$$

当 $c$ 较小时，这一复杂度表现非常优秀。
