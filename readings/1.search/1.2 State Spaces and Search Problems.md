## 1.2 搜索问题与规划智能体

为了创建一个理性规划智能体，我们需要一种方法来**数学化表达智能体所处的环境**。为此，我们必须正式地表示一个**搜索问题**——给定智能体的当前状态（其在环境中的配置），如何到达一个新的状态，使其目标能够以最佳方式实现？一个搜索问题由以下几个元素组成：

- **状态空间（State Space）**：给定世界中所有可能状态的集合。  
- **每个状态下可用的动作集合（Actions）**。  
- **状态转移模型（Transition Model）**：在当前状态执行某一动作后得到的下一个状态。  
- **动作代价（Action Cost）**：执行动作后从一个状态到另一个状态所付出的代价。  
- **起始状态（Start State）**：智能体最初存在的状态。  
- **目标测试（Goal Test）**：一个函数，输入状态并判断其是否为目标状态。

从本质上讲，解决搜索问题的方法是：先考虑起始状态，然后使用动作、状态转移模型和代价方法探索状态空间，迭代计算各个状态的子状态，直到到达目标状态，此时便确定了从起始状态到目标状态的路径（通常称为**计划**）。状态被考虑的顺序由**预定策略**决定。我们将在后面讨论不同策略类型及其适用性。

---

### 1.2.0 世界状态与搜索状态的区别

在继续介绍如何解决搜索问题之前，需要注意**世界状态**（World State）与**搜索状态**（Search State）的区别：

- **世界状态**：包含关于当前状态的所有信息。  
- **搜索状态**：只包含规划所需的必要信息（主要是为了节约空间）。

为了说明这些概念，我们使用本课程的经典例子——**吃豆人（Pacman）**。  
游戏规则：吃豆人必须在迷宫中导航，吃掉迷宫中的所有小豆子，同时避免被巡逻的恶意鬼怪吃掉。如果吃到大豆子，吃豆人会在一段时间内免疫鬼怪，并获得吃掉鬼怪的能力来获得积分。

![Pacman 示例](../../image/pacman_example.png)

假设一个简化版本的游戏：迷宫中只有吃豆人和豆子。我们可以提出两个不同的搜索问题：  

1. **路径搜索（Pathing）**：从位置 $(x_1, y_1)$ 最优地移动到位置 $(x_2, y_2)$。  
2. **吃掉所有豆子（Eat-all-dots）**：尽可能快地吃掉迷宫中的所有豆子。

具体定义如下：

#### 路径搜索（Pathing）

- **状态（States）**：$(x, y)$ 位置  
- **动作（Actions）**：北、南、东、西  
- **状态转移模型（Transition Model）**：只更新位置  
- **目标测试（Goal Test）**：$(x, y) = \text{END}$？

#### 吃掉所有豆子（Eat-all-dots）

- **状态（States）**：$(x, y)$ 位置 + 豆子布尔数组  
- **动作（Actions）**：北、南、东、西  
- **状态转移模型（Transition Model）**：更新位置和豆子布尔值  
- **目标测试（Goal Test）**：所有豆子布尔值是否为 false？

注意：**路径搜索（Pathing）** 的状态信息比**吃掉所有豆子（Eat-all-dots）**，因为后者必须维护每个豆子的布尔数组，表示该豆子是否已被吃掉。而一个世界状态可能包含更多信息，例如吃豆人的总移动距离或访问过的所有位置。

---

### 1.2.1 状态空间规模（State Space Size）

在估算解决搜索问题的计算时间时，一个重要问题是**状态空间的大小**。通常使用**乘法原理（fundamental counting principle）**：  

> 如果世界中有 $n$ 个变量对象，它们分别可以取 $x_1, x_2, \dots, x_n$ 个不同值，那么状态总数为 $x_1 \cdot x_2 \cdot \dots \cdot x_n$。

![状态空间规模](../../image/state_space_size.png)

以吃豆人为例：

- 吃豆人位置：120 个不同 $(x, y)$ 位置  
- 吃豆人方向：北、南、东、西，共 4 种可能  
- 鬼怪位置：2 个鬼怪，每个可以在 12 个位置  
- 豆子配置：30 个豆子，每个豆子可能被吃或未被吃  

状态空间总大小：

$$
120 \cdot 4 \cdot 12^2 \cdot 2^{30}
$$

---

### 1.2.2 状态空间图与搜索树（State Space Graphs and Search Trees）

在我们已经建立了状态空间的概念以及定义一个状态空间所需的四个组成部分之后，我们几乎可以开始解决搜索问题了。最后一个关键概念是**状态空间图（State Space Graph）**和**搜索树（Search Tree）**。

回顾一下，图（Graph）是由一组节点（nodes）和连接这些节点的边（edges）组成的集合。边可能还带有权重（weight）。  

- **状态空间图**：节点表示状态，从状态指向其子状态的有向边表示动作，边的权重表示执行该动作的代价。  
- 通常，状态空间图非常大，无法完全存储在内存中（即使是我们之前的简单吃豆人例子，也有约 $10^{13}$ 个状态！），但概念上它对于理解搜索问题非常有帮助。  
- 在状态空间图中，每个状态只出现一次——没有必要重复表示同一状态，这一点对于推理搜索问题非常重要。

与状态空间图不同，**搜索树**没有状态出现次数的限制。这是因为虽然搜索树也是一种图，节点是状态，边是动作，但每个节点不仅编码状态本身，还编码从起始状态到该状态的完整路径（或计划）。  

例如，考虑状态空间图中一条高亮路径：  

![图和树](../../image/graph_and_tree.png)

$$
S → d → e → r → f → G
$$

在对应的搜索树中，这条路径通过从根节点 S 到高亮目标状态 G 的路径表示。同样，状态空间图中从起始节点到其他任意节点的每一条路径，在搜索树中都会有对应的路径。从一个状态到另一个状态通常存在多种路径，因此状态在搜索树中可能出现多次。因此，搜索树的规模通常大于或等于其对应的状态空间图。

由于即使是简单问题，状态空间图本身也可能非常庞大，那么问题来了：如果无法在内存中表示这些结构，我们如何进行有效计算呢？答案在于**按需计算当前状态的子状态**：  

- 仅存储当前正在处理的状态  
- 使用对应的 `getNextState`、`getAction` 和 `getActionCost` 方法按需生成新状态  

通常，搜索问题是通过搜索树来解决的，我们会**非常谨慎地存储少量节点**，一次只观察部分节点，并迭代地用子节点替换父节点，直到到达目标状态。  

对于搜索树节点的迭代替换顺序，有多种方法可以选择，接下来我们将介绍这些方法。


#### 个人补充

### 豆子布尔数组（Dot Booleans Array）

在吃豆人（Pacman）的搜索问题中，**吃掉所有豆子（Eat-all-dots）**的状态不仅要记录吃豆人的位置，还要记录哪些豆子已经被吃掉。  

- 每个豆子用一个**布尔值（Boolean）**表示：  
  - `true` 或 `1` 表示该豆子 **未被吃**  
  - `false` 或 `0` 表示该豆子 **已经被吃掉**  

- 所有豆子对应的布尔值排列成一个**数组（Array）**，这个数组就叫做“豆子布尔数组”。  

#### 举例

假设迷宫中有 5 个豆子，状态可能表示为：

| 豆子编号 | 1 | 2 | 3 | 4 | 5 |
|-----------|---|---|---|---|---|
| 状态      | 1 | 0 | 1 | 1 | 0 |

解释：

- 豆子 1、3、4 还没有被吃（值为 1）  
- 豆子 2、5 已经被吃掉（值为 0）  

#### 作用

- **搜索状态**中必须保存这个数组，因为智能体要规划如何吃掉所有豆子。  
- 与单纯的路径搜索不同，这个数组记录了额外信息，使状态包含**迷宫中豆子的当前分布情况**。  
- 随着吃豆人的移动，数组会不断更新（相应豆子的布尔值变为 `false`）。

### 按需计算子状态（On-Demand State Generation）

问题来源：

- 即使是一个简单的吃豆人问题，**状态空间图的规模可能非常巨大**。  
  例如之前计算的吃豆人状态空间大约有 $10^{13}$ 个状态，这显然无法全部存储在内存中。  
- 如果我们试图把整个状态空间图存下来，电脑的内存肯定不够。

解决方法：

**按需生成（on-demand）子状态**，也就是：

1. **只存储当前正在处理的状态**  
   - 你不需要把整个状态空间都存下来，只存储你此刻需要探索的节点。  
   - 比如当前吃豆人所在的位置和豆子布尔数组。

2. **动态生成下一个状态**  
   - 当你需要探索动作时，调用方法计算下一个状态，而不是提前存储所有可能状态。  
   - 常用方法：
     - `getNextState(state, action)`：给定当前状态和动作，返回下一个状态  
     - `getAction(state)`：返回当前状态可采取的动作  
     - `getActionCost(state, action)`：返回从当前状态执行该动作的代价  

**比喻理解：**

- 假设迷宫有 1000 条路，如果你提前画出所有路径图，需要画出所有可能的路线，太占地方了。  
- 实际上，你只需要知道**现在走到哪个位置**，然后**按需计算下一步能走到哪几个位置**就够了。  
- 随着搜索进行，你不断替换当前状态为子状态，逐步找到目标，而不需要存储整个迷宫的所有可能路径。

**关键点：**

- 这种方法可以显著节省内存。  
- 也是为什么**搜索问题通常用搜索树来解决**，而不是先画出完整的状态空间图。  
- 搜索树节点不仅包含状态，还记录从起始状态到当前状态的路径（方便回溯或生成计划）。
