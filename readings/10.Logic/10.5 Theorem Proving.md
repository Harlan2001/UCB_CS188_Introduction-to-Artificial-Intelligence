# 10.5 定理证明

另一种方法是将推理规则应用于知识库 \(KB\)，以证明 \(KB \models q\)。例如，如果我们的知识库包含 \(A\) 和 \(A \Rightarrow B\)，那么我们可以推断出 \(B\)（这个规则被称为 **Modus Ponens**）。前面提到的两种算法利用事实 ii.)，即将 \(A \wedge \neg B\) 写成 CNF，并显示它是可满足还是不可满足。

我们也可以使用三条推理规则来证明蕴含：

1. 如果我们的知识库包含 \(A\) 和 \(A \Rightarrow B\)，我们可以推断出 \(B\)（Modus Ponens）。
2. 如果我们的知识库包含 \(A \wedge B\)，我们可以推断出 \(A\)。同样也可以推断出 \(B\)（与消解，And-Elimination）。
3. 如果我们的知识库包含 \(A\) 和 \(B\)，我们可以推断出 \(A \wedge B\)（消解，Resolution）。

最后一条规则构成了**消解算法（Resolution Algorithm）**的基础，该算法将其迭代地应用于知识库及新推导出的句子，直到：

- 推导出 \(q\)，此时我们证明了 \(KB \models q\)；或者
- 没有更多可推导的内容，此时 \(KB \not\models q\)。

然而，在知识库仅包含文字（符号本身）和蕴含的特殊情况下：

\[
(P_1 \wedge \cdots \wedge P_n \Rightarrow Q) \equiv (\neg P_1 \vee \cdots \vee \neg P_n \vee Q)
\]

我们可以在与知识库大小线性相关的时间内证明蕴含。一种算法——**正向链（Forward Chaining）**——会遍历每条前提（左侧）已知为真的蕴含语句，将结论（右侧）添加到已知事实列表中。这个过程会重复，直到 \(q\) 被加入到已知事实列表，或者没有更多内容可推导。

![](../../image/10.Logic/Forward-Chaining-algorithm.png)