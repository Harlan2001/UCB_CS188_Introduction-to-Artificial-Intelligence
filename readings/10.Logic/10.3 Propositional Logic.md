就像其他语言一样，逻辑也有多种方言。我们将介绍两种：命题逻辑（propositional logic）和一阶逻辑（first-order logic）。命题逻辑由命题符号组成的句子构成，这些符号可能通过逻辑连接词连接。命题符号通常用单个大写字母表示，每个命题符号代表关于世界的一个原子命题。一个模型（model）是对所有命题符号赋值为真或假的过程，我们可以将其视为一个“可能的世界”。例如，如果我们有命题 A = “今天下雨了” 和 B = “我忘带伞了”，则可能的模型（或“世界”）有：

- {A=true, B=true} （“今天下雨了，并且我忘带伞了。”）
- {A=true, B=false} （“今天下雨了，但我没忘带伞。”）
- {A=false, B=true} （“今天没下雨，但我忘带伞了。”）
- {A=false, B=false} （“今天没下雨，并且我没忘带伞。”）

一般来说，对于 N 个符号，有 2^N 种可能的模型。我们称一个句子是**有效的（valid）**，如果它在所有模型中都为真（例如 True）；称它是**可满足的（satisfiable）**，如果至少在一个模型中为真；称它是**不可满足的（unsatisfiable）**，如果在任何模型中都不为真。例如，句子 A ∧ B 是可满足的，因为它在模型 1 中为真，但不是有效的，因为在模型 2、3、4 中为假。另一方面，¬A ∧ A 是不可满足的，因为无论 A 如何选择，都不可能为真。

下面列出一些有用的逻辑等价式，可用于将句子简化为更容易处理和推理的形式。

![](../../image/10.Logic/logical_equivalences.png)

逻辑等价式（Logical Equivalences）

命题逻辑中一个特别有用的语法是**合取范式（conjunctive normal form, CNF）**，它是**子句的合取（AND of clauses）**，每个子句是字面量的析取（OR of literals）。其一般形式为：

\[
(P_1 ∨ ⋯ ∨ P_i) ∧ ⋯ ∧ (P_j ∨ ⋯ ∨ P_n)
\]

即是“AND”的“OR”。正如我们将看到的，这种形式的句子适用于某些分析。重要的是，每个逻辑句子都有一个逻辑等价的 CNF 形式。这意味着我们可以将知识库中包含的所有信息（知识库本质上是不同句子的合取）表示为一个大的 CNF 语句，通过将这些 CNF 语句“AND”在一起。

CNF 表示在命题逻辑中尤为重要。下面我们展示一个将句子转换为 CNF 的例子。假设我们有句子 A ⇔ (B ∨ C)，我们想将其转换为 CNF。推导过程基于如下规则：

1. **消去 ⇔**：表达式变为  
\[
(A ⇒ (B ∨ C)) ∧ ((B ∨ C) ⇒ A)
\]  
使用双条件消去法。

2. **消去 ⇒**：表达式变为  
\[
(¬A ∨ B ∨ C) ∧ (¬(B ∨ C) ∨ A)
\]  
使用蕴含消去法。

3. **CNF 表示中，¬ 只能作用于字面量**。使用德摩根定律得到：  
\[
(¬A ∨ B ∨ C) ∧ ((¬B ∧ ¬C) ∨ A)
\]

4. **最后应用分配律**得到：  
\[
(¬A ∨ B ∨ C) ∧ (¬B ∨ A) ∧ (¬C ∨ A)
\]

最终表达式是三个 OR 子句的合取，因此它处于 CNF 形式。
