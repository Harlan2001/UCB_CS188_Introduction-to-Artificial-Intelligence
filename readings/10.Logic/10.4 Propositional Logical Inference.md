# 命题逻辑推论 (Propositional Logical Inference)

逻辑之所以有用且强大，是因为它能够从已知信息中推导出新的结论。为了定义推理问题，我们首先需要一些术语。

我们说句子 A **蕴涵**（entail）句子 B，如果在所有 A 为真的模型中，B 也为真。我们用符号表示为：

\[
A ⊨ B
\]

注意，如果 \(A ⊨ B\)，则 A 的模型是 B 模型的子集，即 \(M(A) ⊆ M(B)\)。推理问题可以表述为判断：

\[
KB ⊨ q
\]

其中 \(KB\) 是我们的逻辑句子知识库，\(q\) 是某个查询。例如，如果 Elicia 发誓再也不去 Crossroads，我们就可以推断，当寻找朋友一起吃晚餐时，我们不会找到她。

我们使用两个有用的定理来展示蕴涵关系：

1. \(A ⊨ B\) 当且仅当 \(A ⇒ B\) 是有效的（valid）。  
   通过证明 \(A ⇒ B\) 有效来证明蕴涵关系称为**直接证明（direct proof）**。

2. \(A ⊨ B\) 当且仅当 \(A ∧ ¬B\) 是不可满足的（unsatisfiable）。  
   通过证明 \(A ∧ ¬B\) 不可满足来证明蕴涵关系称为**反证法（proof by contradiction）**。

---

# 10.4.1 模型检验

一种简单的算法用于检查是否有 \(KB \models q\) 是枚举所有可能的模型，并检查在所有使 \(KB\) 为真的模型中，\(q\) 是否也为真。这种方法称为**模型检验**。对于符号数量可行的句子，可以通过画出真值表来完成枚举。

对于命题逻辑系统，如果有 \(N\) 个符号，则需要检查 \(2^N\) 个模型，因此该算法的时间复杂度为 \(O(2^N)\)，而在一阶逻辑中，模型的数量是无限的。事实上，命题蕴含问题被认为是**co-NP 完全**的。虽然最坏情况的运行时间不可避免地是问题规模的指数函数，但实际上存在一些算法可以更快地终止。我们将讨论两种用于命题逻辑的模型检验算法。

第一种算法由 **Davis、Putnam、Logemann 和 Loveland** 提出（我们称之为 **DPLL 算法**），本质上是一种针对可能模型的**深度优先回溯搜索**，并使用三种技巧来减少过度回溯。该算法旨在解决可满足性问题，即给定一个句子，找到对所有符号有效的赋值。如前所述，蕴含问题可以归约为可满足性问题（证明  
\(A \wedge \neg B\)  
不可满足），DPLL 特别接受 CNF 形式的问题。可满足性可以被表述为一个约束满足问题（CSP）如下：将变量（节点）设为符号，将约束设为 CNF 所施加的逻辑约束。然后 DPLL 会持续为符号分配真值，直到找到一个满足模型，或者某个符号在不违反逻辑约束的情况下无法赋值，此时算法会回溯到上一个有效赋值。然而，DPLL 相比简单回溯搜索做了三项改进：

1. **提前终止（Early Termination）**：如果一个子句中的任意符号为真，则该子句为真。因此，即使在所有符号被赋值之前，也可能知道整个句子为真。同样，如果任意单个子句为假，则整个句子为假。在所有变量赋值之前提前检查句子是否可判断为真或假，可以防止不必要地在子树中徘徊。

2. **纯符号启发式（Pure Symbol Heuristic）**：纯符号是指在整个句子中只以正形式（或只以负形式）出现的符号。纯符号可以立即被赋值为真或假。例如，在句子  
\[
(A \vee B) \wedge (\neg B \vee C) \wedge (\neg C \vee A)
\]  
中，我们可以识别 \(A\) 为唯一的纯符号，并立即将 \(A\) 赋值为真，从而将可满足性问题简化为仅需为  
\((\neg B \vee C)\)  
寻找满足赋值。

3. **单子句启发式（Unit Clause Heuristic）**：单子句是仅包含一个文字的子句，或者是一个文字加上多个假的析取。在单子句中，我们可以立即为文字赋值，因为只有一个有效赋值。例如，\(B\) 必须为真，才能使单子句  
\[
(B \vee false \vee \dots \vee false)
\]  
为真。

## DPLL 算法

![](../../image/10.Logic/DPLL_alg.png)

# 10.4.2 DPLL 示例

假设我们有以下合取范式（CNF）句子：

\[
(\neg N \vee \neg S) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L) \wedge (S)
\]

我们希望使用 DPLL 算法来确定它是否可满足。假设我们使用固定的变量顺序（字母顺序）和固定的值顺序（先真后假）。

在每次递归调用 DPLL 函数时，我们需要跟踪三件事情：

- **model** 是到目前为止我们已赋值的符号及其对应值的列表。  
- **symbols** 是仍未赋值、需要继续赋值的符号列表。  
- **clauses** 是在本次调用或未来递归调用 DPLL 时仍需考虑的 CNF 子句（析取式）列表。

我们从调用 DPLL 开始，此时 **model** 为空（尚未赋值任何符号），**symbols** 包含原句子中的所有符号，**clauses** 包含原句子中的所有子句。

我们最初的 DPLL 调用如下：

**model:**  \{ \}  

**symbols:**  
\[
L, M, N, P, Q, R, S
\]  

**clauses:**  
\[
(\neg N \vee \neg S) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L) \wedge (S)
\]

首先，我们应用**提前终止（Early Termination）**：检查在当前 model 下，是否每个子句都为真，或者至少有一个子句为假。由于此时 model 尚未为任何符号赋值，我们还无法判断哪些子句为真或假。

接下来，我们检查**纯文字（Pure Literal）**。没有符号仅以非否定形式出现，或仅以否定形式出现，因此没有可以简化的纯文字。例如，\(N\) 不是纯文字，因为第一个子句使用了否定形式 \(\neg N\)，而第二个子句使用了非否定形式 \(N\)。

然后，我们检查**单子句（Unit Clause）**（仅包含一个符号的子句）。这里有一个单子句 \(S\)。为了使整个句子为真，我们知道 \(S\) 必须为真（没有其他方式能满足该子句）。因此，我们可以再次调用 DPLL，将 \(S\) 在 model 中赋值为真，同时从需要赋值的符号列表中移除 \(S\)。

我们的第二次 DPLL 调用如下：

**model:**  \[\{ S: T \}\]  

**symbols:**  
\[
L, M, N, P, Q, R
\]  

**clauses:**  
\[
(\neg N \vee \neg S) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L) \wedge (S)
\]

首先，我们可以通过将 model 中的新赋值代入子句来简化子句（\(S\) 为真，\(\neg S\) 为假）：

\[
(\neg N \vee F) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L) \wedge (T)
\]

进一步简化为：

\[
(\neg N) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L)
\]

使用我们新的简化子句后，我们可以检查**提前终止**。我们仍然没有足够的信息来判断所有句子都为真，或者至少有一个句子为假。

接下来，我们检查**纯文字（Pure Literal）**。如前所述，没有符号仅以非否定形式出现，或仅以否定形式出现。

然后，我们检查**单子句（Unit Clause）**。这里有一个单子句 \((\neg N)\)。为了使整个句子为真，\((\neg N)\) 必须为真，因此 \(N\) 必须为假。

因此，我们可以再次调用 DPLL，将 \(N\) 在 model 中赋值为假，同时从需要赋值的符号列表中移除 \(N\)。我们还可以在 DPLL 中使用从此调用计算出的简化子句（即我们已经将 \(S\) 简化后的子句）。

我们的第三次 DPLL 调用如下：

**model:**  
\[
\{
S: T,  
N: F
\}  
\]

**symbols:**  
\[
L, M, P, Q, R
\]  

**clauses:**  
\[
(\neg N) \wedge (M \vee Q \vee N) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee N) \wedge (\neg R \vee \neg L)
\]

在本次调用中，我们首先通过将 model 中的新赋值代入子句来简化子句（\(N\) 为假，\(\neg N\) 为真）：

\[
(T) \wedge (M \vee Q \vee F) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P \vee F) \wedge (\neg R \vee \neg L)
\]

进一步简化为：

\[
(M \vee Q) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

使用我们新的简化子句，我们先检查**提前终止**，然后检查**纯文字**。如前所述，这两者都没有发现。

接下来，我们检查**单子句**。此时没有仅剩一个符号的子句。

此时，我们需要尝试为一个变量赋值。按照固定的变量顺序，我们首先为 \(M\) 赋值；按照固定的值顺序，我们先尝试将 \(M\) 赋值为真。如果将 \(M\) 赋值为真导致句子不可满足，则需要回溯并尝试将 \(M\) 赋值为假。如果将 \(M\) 赋值为假仍然不可满足，那么整个句子将不可满足。换句话说，我们现在将对 DPLL 进行两次递归调用，一次将 \(M\) 赋值为真，一次将 \(M\) 赋值为假，并检查哪一个能产生可满足的赋值。

在 \(M\) 为真的分支上的第一次 DPLL 调用中，我们将 \(M\) 赋值为真加入 model，并使用上一次调用简化后的子句：

**model:**  
\[
\{
S: T,  
N: F,  
M: T
\}
\]  

**symbols:**  
\[
L, P, Q, R
\]  

**clauses:**  
\[
(M \vee Q) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

首先，我们通过将 model 中的新赋值代入子句来简化子句（\(M\) 为真）：

\[
(T \vee Q) \wedge (L \vee F) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

进一步简化为：

\[
(L) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

使用我们新的简化子句，我们检查**提前终止**；如前所述，没有发现。然而，我们确实找到了一个**纯文字（Pure Literal）**，即 \(\neg Q\)（回想一下，由于没有 \(Q\) 的实例，只有 \(\neg Q\) 的实例，所以它算作纯文字）。我们将 \(Q\) 设为假，使得 \(\neg Q\) 为真，然后继续。

在 \(M\) 为真的分支上的第二次 DPLL 调用如下：

**model:**  
\[
\{
S: T,  
N: F,  
M: T,  
Q: F
\}  
\] 
**symbols:**  
\[
L, P, R
\]  

**clauses:**  
\[
(L) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

我们相应地简化子句：

\[
(L) \wedge (L \vee T) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

进一步简化为：

\[
(L) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

检查**提前终止**和**纯文字**，没有发现任何可用的情况。但我们找到了单子句 \((L)\)，可以将其设为真。

在这个同一分支上 \(M\) 为真的下一次调用中，我们得到：

**model:**  
\[
\{
S: T,  
N: F,  
M: T,  
Q: F,  
L: T
\}  
\]
**symbols:**  
\[
P, R
\]  

**clauses:**  
\[
(L) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

让我们简化子句：

\[
(T) \wedge (F \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee F)
\]

进一步简化为：

\[
(\neg P) \wedge (R \vee P) \wedge (\neg R)
\]

检查**提前终止**和**纯文字**，仍然没有发现。检查**单子句**时，我们找到 \((\neg P)\)。我们将该表达式设为真，即将 \(P\) 赋值为假，用于下一次 DPLL 调用。

我们的下一次调用如下：

**model:**  
\[
\{
S: T,  
N: F,  
M: T,  
Q: F,  
L: T,  
P: F
\}  
\] 

**symbols:**  
\[
R
\]  

**clauses:**  
\[
(\neg P) \wedge (R \vee P) \wedge (\neg R)
\]

我们将 \(P\) 设为假后，得到简化后的子句：

\[
(T) \wedge (R \vee F) \wedge (\neg R)
\]

进一步简化为：

\[
(R) \wedge (\neg R)
\]

我们检查**提前终止**。注意这个句子同时包含 \(R\) 和 \(\neg R\)，它们不可能同时为真。因此此时可以判断该句子**不可满足**。

由于 \(M\) 为真的分支以不可满足句子结束，我们回溯到赋值 \(M\) 为真之前的状态，并尝试用 \(M\) 为假进行 DPLL 调用。  

在 \(M\) 为假的分支上的第一次 DPLL 调用如下：

**model:**  
\[
\{
S: T,  
N: F,  
M: F
\}  
\]

**symbols:**  
\[
L, P, Q, R
\]  

**clauses:**  
\[
(M \vee Q) \wedge (L \vee \neg M) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

我们通过将 model 中的新赋值代入子句来简化子句（\(M\) 为假）：

\[
(F \vee Q) \wedge (L \vee T) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

进一步简化为：

\[
(Q) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

我们无法**提前终止**，也没有找到**纯文字**。我们发现了单子句 \(Q\)，因此进行另一次 DPLL 调用，将 \(Q\) 设为真（并从符号列表中

在 \(M\) 为假的分支上的第二次 DPLL 调用如下：
**model:**  
\[
\{
S: T,  
N: F,  
M: F,  
Q: T
\}  
\]

**symbols:**  
\[
L, P, R
\]  

**clauses:**  
\[
(Q) \wedge (L \vee \neg Q) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

将新赋值代入子句（\(Q\) 为真）后：

\[
(T) \wedge (L \vee F) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

进一步简化为：

\[
(L) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

我们无法**提前终止**，也没有发现**纯文字**。我们找到了单子句 \(L\)，因此进行下一次 DPLL 调用，将 \(L\) 设为真（并从符号列表中移除）。

在 \(M\) 为假的分支上的第三次 DPLL 调用如下：

**model:**  
\[
\{
S: T,  
N: F,  
M: F,  
Q: T,  
L: T
\}  
\] 

**symbols:**  
\[
P, R
\]  

**clauses:**  
\[
(L) \wedge (\neg L \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee \neg L)
\]

将新赋值代入子句（\(L\) 为真）后：

\[
(T) \wedge (F \vee \neg P) \wedge (R \vee P) \wedge (\neg R \vee F)
\]

进一步简化为：

\[
(\neg P) \wedge (R \vee P) \wedge (\neg R)
\]

我们无法**提前终止**，也没有发现**纯文字**。我们找到了两个单子句 \((\neg P)\) 和 \((\neg R)\)。按照我们的变量顺序，我们首先选择 \(P\)，因此进行下一次 DPLL 调用，将 \(P\) 设为假（并从符号列表中移除）。

在 \(M\) 为假的分支上的第三次 DPLL 调用如下：

**model:**  
\[
\{
S: T,  
N: F,  
M: F,  
Q: T,  
L: T,  
P: F
\}  
\]  

**symbols:**  
\[
R
\]  

**clauses:**  
\[
(\neg P) \wedge (R \vee P) \wedge (\neg R)
\]

将新赋值代入子句（\(P\) 为假）后：

\[
(T) \wedge (R \vee F) \wedge (\neg R)
\]

进一步简化为：

\[
(R) \wedge (\neg R)
\]

我们检查**提前终止**。注意，这个句子同时包含 \(R\) 和 \(\neg R\)，它们不可能同时为真。因此，此时可以判断该句子**不可满足**。

由于 \(M\) 为真和 \(M\) 为假的赋值都导致句子不可满足，我们可以得出结论：整个句子**不可满足**，至此完成。
